<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>ESA 8 - Lichter auf einer Kreisbahn mit Toon Shading</title>
    <link rel="stylesheet" href="style.css">

    <script src="gl-matrix.js"></script>
    <script src="GVT_Src_vertexData_plane.js"></script>
    <script src="GVT_Src_vertexData_sphere.js"></script>
    <script src="GVT_Src_vertexData_torus.js"></script>
    <script src="GVT_Src_vertexData_plane.js"></script>
    <script src="BEL_Src_tpl.js"></script>
    <script type="x-shader/x-vertex" id="vertexshader">
        attribute vec3 aPosition;
        attribute vec3 aNormal;

        uniform mat4 uPMatrix;
        uniform mat4 uMVMatrix;
        uniform mat3 uNMatrix;

        varying vec3 vNormal;
        varying vec4 vPosition;

        void main(){
            // Calculate vertex position in eye coordinates.
            vec4 tPosition = uMVMatrix * vec4(aPosition, 1.0);
            // Calculate projektion.
            gl_Position = uPMatrix * tPosition;

            vec3 tNormal = normalize(uNMatrix * aNormal);

            vPosition = tPosition;
            vNormal = tNormal;
        }
    </script>
    <script type="x-shader/x-fragment" id="fragmentshader">
        precision mediump float;

        varying vec3 vNormal;
        varying vec4 vPosition;

        // Material.
        struct PhongMaterial {
            vec3 ka;
            vec3 kd;
            vec3 ks;
            float ke;
        };
        uniform PhongMaterial material;

        // Ambient light.
        uniform vec3 ambientLight;

        // Pointlights.
        const int MAX_LIGHT_SOURCES = 8;
        struct LightSource {
            bool isOn;
            vec3 position;
            vec3 color;
        };
        uniform LightSource light[MAX_LIGHT_SOURCES];

        uniform bool useToon;
        uniform int uToonLevels;
        uniform float uSpecThreshold;

        //Hilfsfunktion
        float quantize01(float x, int levels) {
        float L = float(levels);
        if (levels <= 1) return step(0.0, x);
        return floor(clamp(x, 0.0, 1.0) * (L - 1.0) + 1e-5) / (L - 1.0);
        }

        // Phong pro Lichtquelle
        vec3 phongLight(vec3 p, vec3 n, vec3 v, LightSource l) {
            vec3 Lc = l.color;
            vec3 s = normalize(l.position - p);
            vec3 r = reflect(-s, n);
            float sn = max(dot(s, n), 0.0);
            float rv = max(dot(r, v), 0.0);
            vec3 diffuse = material.kd * Lc * sn;
            vec3 specular = material.ks * Lc * pow(rv, material.ke);
            return diffuse + specular;
        }

        // Toon pro Lichtquelle
        vec3 toonLight(vec3 p, vec3 n, vec3 v, LightSource l) {
            vec3 Lc = l.color;
            vec3 s = normalize(l.position - p);
            vec3 r = reflect(-s, n);
            float sn = max(dot(s, n), 0.0);
            float rv = max(dot(r, v), 0.0);

            // Diffuse in Bänder zerlegen
            float shade = quantize01(sn, uToonLevels);

            // Spekular als hartes Highlight-Band
            float spec = pow(rv, material.ke);
            float specBand = step(uSpecThreshold, spec);

            vec3 diffuse = material.kd * Lc * shade;
            vec3 specular = material.ks * Lc * specBand;
            return diffuse + specular;
        }

        // Aufsummieren über alle Lichter
        vec3 shadePhong(vec3 p, vec3 n, vec3 v) {
            vec3 result = material.ka * ambientLight;
            for (int j = 0; j < MAX_LIGHT_SOURCES; j++) {
                if (light[j].isOn) {
                    result += phongLight(p, n, v, light[j]);
                }
            }
            return result;
        }

        vec3 shadeToon(vec3 p, vec3 n, vec3 v) {
            vec3 result = material.ka * ambientLight;
            for (int j = 0; j < MAX_LIGHT_SOURCES; j++) {
                if (light[j].isOn) {
                    result += toonLight(p, n, v, light[j]);
                }
            }
            return result;
        }

        void main() {
            // View- und Normalvektoren berechnen
            vec3 v = normalize(-vPosition.xyz);
            vec3 n = normalize(vNormal);

            vec3 color = useToon ? shadeToon(vPosition.xyz, n, v)
                                 : shadePhong(vPosition.xyz, n, v);

            gl_FragColor = vec4(color, 1.0);
        }
    </script>

</head>
<body onload="app.start()">

<h1 id="title">ESA 8 - Lichter auf einer Kreisbahn mit Toon Shading</h1>
<canvas id="canvas" width="500" height="500"></canvas>


<div id="hinweise">
    <h2>Allgemeine Hinweise</h2>
    <ul>
        <li>
            <b>Steuerung:</b>
            R: Lichtanimation starten/Stoppen <br>
            L: Lichter Frame weiter <br>
            T: Toon Shader aktivieren/deaktivieren <br>

            O: Ortho <br>
            F: Frustum <br>
            P: Perspective <br>

            C: Kamera Orbit <br>
            H: Kamera hoch/runter <br>
            D: Kamera Distanz <br>

            V: Kamera FOV<br>


        </li>
        <li>
            <b>Darstellung:</b>
            Zwei Kugeln und ein Torus auf einem Boden
        </li>
        <li>
            <b>Quelle:</b>
            Kursmaterialien. Cell-Shading war mir bereits bekannt, daher keine Quellen notwendig
        </li>
    </ul>
</div>
<div id="Buttons">
    <button id="overviewButton" onclick="window.location.href='../index.html'">Zur Gesamtuebersicht</button>

</div>
</body>
<html>