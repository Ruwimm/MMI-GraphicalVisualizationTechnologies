<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>ESA 4 - Parametrisierte Flaechen</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
<h1 id="title">ESA 4 - Parametrisierte Flaechen</h1>
<canvas id="canvas" width="400" height="400"></canvas>

<div id="hinweise">
    <h2>Allgemeine Hinweise</h2>
    <ul>
        <li>
            <b>Darstellung:</b>
            Hier werden eine Kugel, ein Torus und ein Custom Shape (Dach/Cone) nacheinander dargestellt
        </li>
        <li>
            <b>Quelle:</b>
            Es wurden mathematische Formeln als Referenz eigenstaendig ausprobiert.
        </li>
    </ul>
</div>

<div id="Buttons">
    <button id="overviewButton" onclick="window.location.href='../index.html'">Zur Gesamtuebersicht</button>
    <button id="cycleBtn">Form wechseln</button>
    <button id="surfaceBtn">Flaeche aus</button>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    if (!gl) {
        alert('WebGL wird nicht unterstützt.');
    }

    // Viewport
    gl.viewport(0, 0, canvas.width, canvas.height);

    // Pipeline setup
    gl.clearColor(0.95, 0.95, 0.95, 1.0);
    gl.frontFace(gl.CCW);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
    gl.enable(gl.POLYGON_OFFSET_FILL);
    gl.polygonOffset(1.0, 1.0);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    // Shader
    const vsSource =
        'attribute vec3 pos;' +
        'varying float vT;' +
        'void main(){' +
        '  gl_Position = vec4(pos, 1.0);' +
        '  vT = clamp(0.5 * pos.y + 0.5, 0.0, 1.0);' +  // mappe y in [0,1]
        '}';

    const fsSource =
        'precision mediump float;' +
        'varying float vT;' +
        'uniform bool uUseFlatColor;' +
        'uniform vec4 uFlatColor;' +
        'uniform vec3 uColorTop;' +
        'uniform vec3 uColorBottom;' +
        'void main(){' +
        '  vec3 grad = mix(uColorBottom, uColorTop, vT);' +
        '  vec4 col = vec4(grad, 1.0);' +
        '  if (uUseFlatColor) col = uFlatColor;' +
        '  gl_FragColor = col;' +
        '}';

    function compileShader(type, source) {
        const sh = gl.createShader(type);
        gl.shaderSource(sh, source);
        gl.compileShader(sh);
        if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
            console.error('Shader-Fehler:', gl.getShaderInfoLog(sh));
            gl.deleteShader(sh);
            return null;
        }
        return sh;
    }

    const vs = compileShader(gl.VERTEX_SHADER, vsSource);
    const fs = compileShader(gl.FRAGMENT_SHADER, fsSource);

    const prog = gl.createProgram();
    gl.attachShader(prog, vs);
    gl.attachShader(prog, fs);
    gl.bindAttribLocation(prog, 0, 'pos');
    gl.linkProgram(prog);
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        console.error('Programm-Link-Fehler:', gl.getProgramInfoLog(prog));
    }
    gl.useProgram(prog);
    const uUseFlatColorLoc  = gl.getUniformLocation(prog, 'uUseFlatColor');
    const uFlatColorLoc     = gl.getUniformLocation(prog, 'uFlatColor');
    const uColorTopLoc      = gl.getUniformLocation(prog, 'uColorTop');
    const uColorBottomLoc   = gl.getUniformLocation(prog, 'uColorBottom');

    // Attribute
    const posAttrib = gl.getAttribLocation(prog, 'pos');
    //const colAttrib = gl.getAttribLocation(prog, 'col'); // konstante Farbe

    // Buffer
    const vboPos = gl.createBuffer();
    const iboLines = gl.createBuffer();
    const iboTris  = gl.createBuffer();

    // Position-Attribut
    gl.bindBuffer(gl.ARRAY_BUFFER, vboPos);
    gl.vertexAttribPointer(posAttrib, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(posAttrib);

    function uploadGeometry(geom) {
        gl.bindBuffer(gl.ARRAY_BUFFER, vboPos);
        gl.bufferData(gl.ARRAY_BUFFER, geom.vertices, gl.STATIC_DRAW);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboLines);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, geom.indicesLines, gl.STATIC_DRAW);
        iboLines.numberOfElements = geom.indicesLines.length;

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboTris);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, geom.indicesTris, gl.STATIC_DRAW);
        iboTris.numberOfElements = geom.indicesTris.length;
    }


    let showSurface = true;

    function draw() {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        const bottom = new Float32Array([1.0, 0.5, 0.2]); // Orange
        const top    = new Float32Array([0.1, 0.6, 1.0]); //Blau

        if (showSurface && iboTris.numberOfElements > 0) {
            gl.uniform1i(uUseFlatColorLoc, 0); // Verlauf benutzen
            gl.uniform3fv(uColorBottomLoc, bottom);
            gl.uniform3fv(uColorTopLoc, top);

            //gl.vertexAttrib4f(colAttrib, 0.0, 1.0, 1.0, 1.0); // Cyan Fläche
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboTris);
            gl.drawElements(gl.TRIANGLES, iboTris.numberOfElements, gl.UNSIGNED_SHORT, 0);
        }
        // Linien konstant blau
        gl.uniform1i(uUseFlatColorLoc, 1); // Flat-Color einschalten
        gl.uniform4f(uFlatColorLoc, 0.2, 0.16, 0.12, 0.25);

        //gl.vertexAttrib4f(colAttrib, 0.0, 0.0, 1.0, 1.0); // Blau  Linien
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboLines);
        gl.drawElements(gl.LINES, iboLines.numberOfElements, gl.UNSIGNED_SHORT, 0);
    }

    // Kugel
    function createSphere(n = 64, m = 64) {
        const vertices = new Float32Array(3 * (n + 1) * (m + 1));
        const indicesLines = new Uint16Array(2 * 2 * n * m);
        const indicesTris  = new Uint16Array(3 * 2 * n * m);

        const dt = 2 * Math.PI / n;
        const dv = Math.PI / m;
        let iLines = 0, iTris = 0;

        for (let i = 0, t = 0; i <= n; ++i, t += dt) {
            for (let j = 0, v = 0; j <= m; ++j, v += dv) {
                const iVertex = i * (m + 1) + j;

                const x = Math.sin(v) * Math.cos(t);
                const y = Math.cos(v);
                const z = Math.sin(v) * Math.sin(t);

                vertices[3 * iVertex + 0] = x;
                vertices[3 * iVertex + 1] = y;
                vertices[3 * iVertex + 2] = z;

                if (j > 0 && i > 0) {
                    // Linien
                    indicesLines[iLines++] = iVertex - 1;
                    indicesLines[iLines++] = iVertex;
                    indicesLines[iLines++] = iVertex - (m + 1);
                    indicesLines[iLines++] = iVertex;

                    // Dreiecke
                    indicesTris[iTris++] = iVertex;
                    indicesTris[iTris++] = iVertex - 1;
                    indicesTris[iTris++] = iVertex - (m + 1);

                    indicesTris[iTris++] = iVertex - 1;
                    indicesTris[iTris++] = iVertex - (m + 1) - 1;
                    indicesTris[iTris++] = iVertex - (m + 1);
                }
            }
        }
        return { vertices, indicesLines, indicesTris };
    }

    // Torus
    function createTorus(n = 128, m = 64, R = 0.6, a = 0.25) {
        const vertices = new Float32Array(3 * (n + 1) * (m + 1));
        const indicesLines = new Uint16Array(2 * 2 * n * m);
        const indicesTris  = new Uint16Array(3 * 2 * n * m);

        const du = 2 * Math.PI / n;
        const dv = 2 * Math.PI / m;
        let iLines = 0, iTris = 0;

        for (let i = 0, u = 0; i <= n; ++i, u += du) {
            for (let j = 0, v = 0; j <= m; ++j, v += dv) {
                const iVertex = i * (m + 1) + j;

                const x = (R + a * Math.cos(v)) * Math.cos(u);
                const y = a * Math.sin(v);
                const z = (R + a * Math.cos(v)) * Math.sin(u);

                vertices[3 * iVertex + 0] = x;
                vertices[3 * iVertex + 1] = y;
                vertices[3 * iVertex + 2] = z;

                if (j > 0 && i > 0) {
                    // Linien
                    indicesLines[iLines++] = iVertex - 1;
                    indicesLines[iLines++] = iVertex;
                    indicesLines[iLines++] = iVertex - (m + 1);
                    indicesLines[iLines++] = iVertex;

                    // Dreiecke
                    indicesTris[iTris++] = iVertex;
                    indicesTris[iTris++] = iVertex - 1;
                    indicesTris[iTris++] = iVertex - (m + 1);

                    indicesTris[iTris++] = iVertex - 1;
                    indicesTris[iTris++] = iVertex - (m + 1) - 1;
                    indicesTris[iTris++] = iVertex - (m + 1);
                }
            }
        }
        return { vertices, indicesLines, indicesTris };
    }

    function createCustomShape(n = 128, m = 64) {
        const vertices = new Float32Array(3 * (n + 1) * (m + 1));
        const indicesLines = new Uint16Array(2 * 2 * n * m);
        const indicesTris  = new Uint16Array(3 * 2 * n * m);

        const dt = 2 * Math.PI / n; // Winkel-Schritt
        const dr = 1 / m;           // Radius-Schritt

        let iLines = 0, iTris = 0;

        for (let i = 0, t = 0; i <= n; ++i, t += dt) {
            for (let j = 0, r = 0; j <= m; ++j, r += dr) {

                const iVertex = i * (m + 1) + j;

                const radius = r;
                const x = radius * Math.cos(t);
                const z = radius * Math.sin(t);
                const y = 1.0 - r; // Spitze bei y=1

                vertices[3 * iVertex + 0] = x;
                vertices[3 * iVertex + 1] = y;
                vertices[3 * iVertex + 2] = z;

                if (j > 0 && i > 0) {
                    // Linien
                    indicesLines[iLines++] = iVertex - 1;
                    indicesLines[iLines++] = iVertex;
                    indicesLines[iLines++] = iVertex - (m + 1);
                    indicesLines[iLines++] = iVertex;

                    // Dreiecke
                    indicesTris[iTris++] = iVertex;
                    indicesTris[iTris++] = iVertex - 1;
                    indicesTris[iTris++] = iVertex - (m + 1);

                    indicesTris[iTris++] = iVertex - 1;
                    indicesTris[iTris++] = iVertex - (m + 1) - 1;
                    indicesTris[iTris++] = iVertex - (m + 1);
                }
            }
        }
        return { vertices, indicesLines, indicesTris };
    }

    // Formen wechseln, Fläche toggeln
    const shapes = ['sphere', 'torus', 'customShape'];
    let currentShapeIndex = 0;

    function setShape(name) {
        const geom =
            name === 'sphere' ? createSphere() :
                name === 'torus'  ? createTorus()  :
                    name === 'customShape'  ? createCustomShape()  : null;
        if (!geom) return;
        uploadGeometry(geom);
        draw();
    }

    function cycleShape() {
        currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
        setShape(shapes[currentShapeIndex]);
    }

    function toggleSurface() {
        showSurface = !showSurface;
        updateSurfaceButtonLabel();
        draw();
    }

    function updateSurfaceButtonLabel() {
        const btn = document.getElementById('surfaceBtn');
        btn.textContent = showSurface ? 'Flaeche aus' : 'Flaeche an';
    }

    // Buttons
    document.getElementById('cycleBtn').onclick = cycleShape;
    document.getElementById('surfaceBtn').onclick = toggleSurface;

    //Anzeige
    updateSurfaceButtonLabel();
    setShape(shapes[currentShapeIndex]);
</script>
</body>
</html>